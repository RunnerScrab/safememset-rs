#![forbid(unsafe_code)]

// Uses transmute::<A,B>() from cve-rs (https://github.com/Speykious/cve-rs),
// which abuses a "soundness" issue in Rust (known since 2015) to somehow
// chain its way into unrestricted type punning.

// I have put what I needed from cve-rs all in this one file to
// emphasize that only nominally "safe" Rust (i.e. Rust without
// any `unsafe` statements/blocks or std::ffi use) is needed to gain
// arbitrary access to anything imported by the Rust stdlib,
// to do pointer arithmetic or anything else C can do.

/// This function works only with JMP/CALL instructions
/// which have an encoded 4 byte offset. You pass a sequence of bytes in
/// or near a function that calls the function you're looking for,
/// adjusting with offset_from_needle as necessary. A bit fragile
fn safely_get_fnaddr_from_iat(needle: &[u8], offset_from_needle: usize) -> usize {
    let mainaddr = transmute::<fn() -> (), usize>(main);
    let mem = transmute::<usize, &[u8; u32::MAX as usize]>(mainaddr);

    if let Some(position) = mem
        .windows(needle.len())
        .position(|window| window == needle)
    {
        let iat_offset_offset: usize = offset_from_needle + position + needle.len();

        let offsetslice = &mem[iat_offset_offset..iat_offset_offset + 4];
        let signed_offset: i32 = (offsetslice[0] as i32)
            | (offsetslice[1] as i32) << (1 << 3)
            | (offsetslice[2] as i32) << (2 << 3)
            | (offsetslice[3] as i32) << (3 << 3);

        //The 4-byte offset encoded in the CALL opcode is relative to the next instruction's address
        let next_op_addr: usize = mainaddr + iat_offset_offset + 4;
        let iat_entry_addr: usize = (signed_offset as i64 + next_op_addr as i64) as usize;
        let p_iat_entry_addr: &usize = transmute::<usize, &usize>(iat_entry_addr);

        let iat_entry_val = *p_iat_entry_addr;

        return iat_entry_val;
    }
    return 0;
}

#[allow(non_snake_case)]
fn main() {
    let mut winapi: SafeWinapi = SafeWinapi {
        h_thismodule: 0,
        h_kernel32: 0,
        h_vcrt: 0,
        pGetModuleHandleA: 0,
        pGetProcAddress: 0,
        pLoadLibraryA: 0,
    };

	//Initialize basic winapi functions
    winapi.initialize();

    //Now we can load any DLL with all of its functions without using unsafe_code
    let GetStdHandle =
        winapi.GetProcAddressAsFn::<fn(i32) -> usize>(winapi.h_kernel32, "GetStdHandle");
    let WriteConsoleA = winapi
        .GetProcAddressAsFn::<fn(usize, usize, u32, &mut usize, usize) -> u8>(
            winapi.h_kernel32,
            "WriteConsoleA",
        );
    let VirtualAlloc = winapi.GetProcAddressAsFn::<fn(usize, usize, u32, u32) -> usize>(
        winapi.h_kernel32,
        "VirtualAlloc",
    );
    let VirtualFree =
        winapi.GetProcAddressAsFn::<fn(usize, usize, u32) -> i32>(winapi.h_kernel32, "VirtualFree");
    
	let hUser32 = winapi.LoadLibraryA("user32");
	if hUser32 == 0
	{
		println!("Failed to load user32.dll");
	}
	else
	{
		println!("Loaded user32.dll at 0x{:x}", hUser32);
	}
	
	let MessageBoxA = winapi.GetProcAddressAsFn::<fn(usize, usize, usize, u32)->i32>(hUser32, "MessageBoxA");

	
	let Sleep = winapi.GetProcAddressAsFn::<fn(u32)->()>(winapi.h_kernel32, "Sleep");
	
	let memcpy =
        winapi.GetProcAddressAsFn::<fn(usize, usize, usize) -> usize>(winapi.h_vcrt, "memcpy");

	


    let hstdout = GetStdHandle(-11);
    let strbytes = make_c_str("Hello WINAPI!\n");
    let pstrbytes = transmute::<&[u8], usize>(&(*strbytes));

    let mut bwritten: usize = 0;

    println!("kernel32 handle: 0x{:x}", winapi.h_kernel32);
    println!("GetModuleHandleA(0) returned 0x{:x}", winapi.h_thismodule);

    WriteConsoleA(
        hstdout,
        pstrbytes,
        (strbytes.len() - 1) as u32,
        &mut bwritten,
        0,
    );
    println!("WriteConsoleA wrote {} bytes", bwritten);

    let machine_code: Vec<u8>;

    if cfg!(debug_assertions) {
        println!("Attempting to read win.bin.");
        machine_code = match std::fs::read("win.bin") {
            Ok(bytearr) => {
                println!("Read win.bin");
                bytearr
            }
            Err(err) => {
                println!("Could not read file: {}", err);
                QUOTE_SHELLCODE_UNQUOTE.to_vec()
            }
        };
    } else {
        machine_code = QUOTE_SHELLCODE_UNQUOTE.to_vec();
    }

    let mem = VirtualAlloc(0, machine_code.len(), 0x1000_u32, 0x40_u32);
    
    if mem != 0 {
        println!("VirtualAlloc succeeded");
    }
	
    memcpy(
        mem,
        transmute::<&[u8], usize>(&machine_code),
        machine_code.len(),
    );

    let pfunc = transmute::<usize, fn(usize, usize) -> u64>(mem);
    let pWriteConsoleA = winapi.GetProcAddress(winapi.h_kernel32, "WriteConsoleA");
    println!("Executing machine code copied to memory block allocated by VirtualAlloc()");

    let pfunc_retval = pfunc(pWriteConsoleA, hstdout);

    println!("Machine code execution complete: returned 0x{:x}", pfunc_retval);

	println!("VirtualFree() {}",
		if VirtualFree(mem, machine_code.len(), 0x4000) != 0 { "succeeded" }
		else { "FAILED" });
	println!("Displaying MessageBoxA in 2s");
	
	Sleep(2000);

    let msgbytes = make_c_str("Rust is completely memory safe outside of unsafe_code.");
    let pmsgbytes = transmute::<&[u8], usize>(&(*msgbytes));
	
	let captionbytes = make_c_str("An Informative Message for Blessed Rustaceans");
    let pcaptionbytes = transmute::<&[u8], usize>(&(*captionbytes));
	
	loop
	{
		let msgbox_retval = MessageBoxA(0, pmsgbytes, pcaptionbytes, 3 | 0x30 | 0x1000);
		println!("{}:{}", msgbox_retval, match msgbox_retval {
			6 => { "User clicked Yes and is blessedly correct"},
			7 => { "User clicked no. Response indicates insufficiently enlightened attitude. Asking again"}
			_ => { "User attempted to cancel. User may not understand. Asking again"}
		});
		if msgbox_retval == 6
		{
			break;
		}
		Sleep(500);
	}
	
}

#[allow(non_snake_case)]
struct SafeWinapi {
    h_thismodule: usize,
    h_kernel32: usize,
    h_vcrt: usize,

    pGetModuleHandleA: usize,
    pGetProcAddress: usize,
    pLoadLibraryA: usize,
}

#[allow(non_snake_case)]
impl SafeWinapi {
    fn LoadLibraryA(&self, name: &str) -> usize {
        let namebytes = make_c_str(name);
        let pnamebytes = transmute::<&[u8], usize>(&(*namebytes));
        let tmpLoadLibraryA = transmute::<usize, fn(usize) -> usize>(self.pLoadLibraryA);
        tmpLoadLibraryA(pnamebytes)
    }

    fn GetProcAddress(&self, hmodule: usize, name: &str) -> usize {
        let namebytes = make_c_str(name);
        let pnamebytes = transmute::<&[u8], usize>(&(*namebytes));
        let tmpGetProcAddress = transmute::<usize, fn(usize, usize) -> usize>(self.pGetProcAddress);
        let returnvalue = tmpGetProcAddress(hmodule, pnamebytes);
		if returnvalue == 0
		{
			println!("GetProcAddress FAILED for {}", name);
		}
		returnvalue
    }

    fn GetProcAddressAsFn<FnType>(&self, hmodule: usize, name: &str) -> FnType {
        transmute::<usize, FnType>(self.GetProcAddress(hmodule, name))
    }

    fn GetModuleHandleA(&self, name: &str) -> usize {
        let namebytes = make_c_str(name);
        let pnamebytes = transmute::<&[u8], usize>(&(*namebytes));
        let tmpGetModuleHandleA = transmute::<usize, fn(usize) -> usize>(self.pGetModuleHandleA);
        tmpGetModuleHandleA(pnamebytes)
    }

    fn initialize(&mut self) {
        let stub_GetProcAddress: &[u8] = &[
            0x48, 0x8d, 0x6c, 0x24, 0x20, 0x48, 0x89, 0xd6, 0x48, 0x89, 0xcf,
        ];
        let stub_GetModuleHandleA: &[u8] = &[
            0x48, 0x8d, 0x6c, 0x24, 0x20, 0x48, 0x89, 0xd6, 0x48, 0x89, 0xcf,
        ];

        self.pGetProcAddress = safely_get_fnaddr_from_iat(stub_GetProcAddress, 30);
        self.pGetModuleHandleA = safely_get_fnaddr_from_iat(stub_GetModuleHandleA, 9);

        let tmpGetModuleHandleA = transmute::<usize, fn(usize) -> usize>(self.pGetModuleHandleA);

        self.h_thismodule = tmpGetModuleHandleA(0);

        self.h_kernel32 = self.GetModuleHandleA("kernel32");

        self.pLoadLibraryA = self.GetProcAddress(self.h_kernel32, "LoadLibraryA");

        //We need to load Kernel32 again because the Rust stdlib only
        //imported some of its available functions, not all
        self.h_kernel32 = self.LoadLibraryA("kernel32");

        //Same for vcruntime140
        self.h_vcrt = self.LoadLibraryA("vcruntime140");
    }
}

fn make_c_str(seq: &str) -> Vec<u8> {
    let a = seq.to_string();
    let mut b = a.into_bytes();
    b.push(0_u8);
    b
}

pub const QUOTE_SHELLCODE_UNQUOTE: &[u8] = &[
	0x53,0x57,0x56,0x41,0x54,0x41,0x55,0x41,0x56,0x41,0x57,0x55,0x48,
	0x89,0xe5,0x48,0x83,0xe4,0xf0,0x48,0x83,0xec,0x20,0x48,0x31,0xdb,
	0x48,0x89,0x0d,0x35,0x04,0x00,0x00,0x48,0x89,0x15,0x26,0x04,0x00,
	0x00,0x48,0x8d,0x0d,0x57,0x04,0x00,0x00,0xe8,0x9a,0x01,0x00,0x00,
	0x48,0x8d,0x0d,0x4b,0x04,0x00,0x00,0x48,0x89,0xc2,0xe8,0x65,0x00,
	0x00,0x00,0x48,0x8d,0x0d,0x76,0x04,0x00,0x00,0xe8,0x7f,0x01,0x00,
	0x00,0x48,0x8d,0x0d,0x6a,0x04,0x00,0x00,0x48,0x89,0xc2,0xe8,0x4a,
	0x00,0x00,0x00,0x48,0x8d,0x0d,0x21,0x04,0x00,0x00,0xe8,0x64,0x01,
	0x00,0x00,0x48,0x8d,0x0d,0x15,0x04,0x00,0x00,0x48,0x89,0xc2,0xe8,
	0x2f,0x00,0x00,0x00,0xe8,0xe8,0x01,0x00,0x00,0x48,0x83,0xc3,0x01,
	0x48,0x81,0xfb,0xff,0x00,0x00,0x00,0xe8,0x34,0x02,0x00,0x00,0x48,
	0xb8,0xef,0xbe,0xbe,0xba,0xfe,0xca,0xed,0xfe,0x48,0x89,0xec,0x5d,
	0x41,0x5f,0x41,0x5e,0x41,0x5d,0x41,0x5c,0x5e,0x5f,0x5b,0xc3,0x53,
	0x41,0x54,0x41,0x55,0x41,0x56,0x41,0x57,0x55,0x48,0x89,0xe5,0x48,
	0x83,0xe4,0xf0,0x48,0x83,0xec,0x20,0x49,0x89,0xca,0x49,0x89,0xd3,
	0x4d,0x31,0xe4,0x41,0xbe,0x24,0x00,0x00,0x00,0x4d,0x31,0xed,0x4c,
	0x89,0xea,0x4c,0x89,0xf1,0xe8,0xad,0x02,0x00,0x00,0x48,0x89,0xc2,
	0x48,0x81,0xe2,0xff,0x00,0x00,0x00,0x49,0x89,0xc0,0x49,0xc1,0xe8,
	0x08,0x49,0x81,0xe0,0xff,0x00,0x00,0x00,0x49,0x89,0xc1,0x49,0xc1,
	0xe9,0x10,0x49,0x81,0xe1,0xff,0x00,0x00,0x00,0x4d,0x8d,0x3a,0x4d,
	0x01,0xe7,0x41,0x8a,0x0f,0x41,0x52,0x41,0x53,0xe8,0x29,0x00,0x00,
	0x00,0x41,0x5b,0x41,0x5a,0x49,0x83,0xc4,0x01,0x4d,0x39,0xdc,0x74,
	0x0e,0x49,0x83,0xc5,0x01,0x4d,0x39,0xf5,0x7c,0xa7,0x4d,0x31,0xed,
	0xeb,0xa2,0x48,0x89,0xec,0x5d,0x41,0x5f,0x41,0x5e,0x41,0x5d,0x41,
	0x5c,0x5b,0xc3,0x53,0x41,0x54,0x41,0x55,0x41,0x56,0x41,0x57,0x55,
	0x48,0x89,0xe5,0x48,0x83,0xe4,0xf0,0x48,0x83,0xec,0x20,0x49,0x89,
	0xcc,0x49,0x89,0xd5,0x4d,0x89,0xc6,0x4d,0x89,0xcf,0xba,0x07,0x00,
	0x00,0x00,0x48,0x8d,0x0d,0x0c,0x03,0x00,0x00,0xe8,0x1b,0x01,0x00,
	0x00,0x4c,0x89,0xe9,0xe8,0x9e,0x00,0x00,0x00,0xba,0x01,0x00,0x00,
	0x00,0x48,0x8d,0x0d,0xfa,0x02,0x00,0x00,0xe8,0x02,0x01,0x00,0x00,
	0x4c,0x89,0xf1,0xe8,0x85,0x00,0x00,0x00,0xba,0x01,0x00,0x00,0x00,
	0x48,0x8d,0x0d,0xe1,0x02,0x00,0x00,0xe8,0xe9,0x00,0x00,0x00,0x4c,
	0x89,0xf9,0xe8,0x6c,0x00,0x00,0x00,0xba,0x01,0x00,0x00,0x00,0x48,
	0x8d,0x0d,0xc9,0x02,0x00,0x00,0xe8,0xd0,0x00,0x00,0x00,0x4c,0x89,
	0xe1,0xe8,0x80,0x00,0x00,0x00,0x48,0x89,0xec,0x5d,0x41,0x5f,0x41,
	0x5e,0x41,0x5d,0x41,0x5c,0x5b,0xc3,0x53,0x48,0x31,0xc0,0x48,0x31,
	0xdb,0x8a,0x19,0x48,0x83,0xc1,0x01,0x48,0x83,0xc0,0x01,0x80,0xfb,
	0x00,0x75,0xf1,0x48,0x83,0xe8,0x01,0x5b,0xc3,0x53,0x41,0xb8,0x0a,
	0x00,0x00,0x00,0x89,0xc8,0x48,0x89,0xd3,0x31,0xd2,0x49,0xf7,0xf0,
	0x89,0xc1,0x83,0xc2,0x30,0x88,0x13,0x48,0x83,0xeb,0x01,0x85,0xc0,
	0x75,0xec,0x48,0x89,0xd8,0x48,0x83,0xc0,0x01,0x5b,0xc3,0x41,0x54,
	0x55,0x48,0x89,0xe5,0x48,0x83,0xe4,0xf0,0x48,0x83,0xec,0x20,0x48,
	0x8d,0x55,0xff,0xe8,0xc0,0xff,0xff,0xff,0x48,0x8d,0x55,0x00,0x48,
	0x29,0xc2,0x48,0x89,0xc1,0xe8,0x4f,0x00,0x00,0x00,0x48,0x89,0xec,
	0x5d,0x41,0x5c,0xc3,0x41,0x54,0x55,0x48,0x89,0xe5,0x48,0x83,0xe4,
	0xf0,0x48,0x83,0xec,0x20,0x88,0x4d,0xf8,0x48,0x8d,0x4d,0xf8,0xba,
	0x01,0x00,0x00,0x00,0xe8,0x29,0x00,0x00,0x00,0x48,0x89,0xec,0x5d,
	0x41,0x5c,0xc3,0x55,0x48,0x89,0xe5,0x48,0x83,0xe4,0xf0,0x48,0x83,
	0xec,0x20,0x48,0x8d,0x0d,0xe5,0x01,0x00,0x00,0xba,0x02,0x00,0x00,
	0x00,0xe8,0x05,0x00,0x00,0x00,0x48,0x89,0xec,0x5d,0xc3,0x41,0x54,
	0x41,0x55,0x41,0x56,0x55,0x48,0x89,0xe5,0x48,0x83,0xe4,0xf0,0x48,
	0x83,0xec,0x20,0x4c,0x8d,0x25,0xb5,0x01,0x00,0x00,0x49,0x89,0xd0,
	0x48,0x89,0xca,0x48,0x8b,0x0d,0xa0,0x01,0x00,0x00,0x4d,0x31,0xc9,
	0x6a,0x00,0x41,0xff,0x14,0x24,0x48,0x89,0xec,0x5d,0x41,0x5e,0x41,
	0x5d,0x41,0x5c,0xc3,0x55,0x48,0x89,0xe5,0x48,0x83,0xe4,0xf0,0x48,
	0x83,0xec,0x20,0x48,0x8d,0x0d,0xa8,0x01,0x00,0x00,0xba,0x04,0x00,
	0x00,0x00,0xe8,0xa9,0xff,0xff,0xff,0x48,0x89,0xec,0x5d,0xc3,0x0f,
	0x28,0xd0,0xf3,0x0f,0x5e,0xd1,0xf3,0x0f,0x2c,0xca,0x66,0x0f,0xef,
	0xd2,0xf3,0x0f,0x2a,0xd1,0xf3,0x0f,0x59,0xca,0xf3,0x0f,0x5c,0xc1,
	0xc3,0x55,0x48,0x89,0xe5,0x48,0x83,0xe4,0xf0,0x48,0x83,0xec,0x20,
	0xf3,0x0f,0x58,0xc1,0xb8,0x00,0x00,0xc0,0x40,0x66,0x0f,0x6e,0xc8,
	0xe8,0xc6,0xff,0xff,0xff,0xba,0x00,0x00,0x80,0x40,0x66,0x0f,0x6e,
	0xca,0x0f,0x28,0xd0,0xf3,0x0f,0x5c,0xc8,0xbf,0x00,0x00,0x80,0x3f,
	0x66,0x0f,0x6e,0xc7,0x0f,0x2f,0xca,0x76,0x1f,0x0f,0x2f,0xc2,0x77,
	0x3b,0xf3,0x0f,0x5d,0xd0,0xf3,0x0f,0x5c,0xc2,0xbe,0x00,0x00,0x7f,
	0x43,0x66,0x0f,0x6e,0xde,0xf3,0x0f,0x59,0xc3,0x48,0x89,0xec,0x5d,
	0xc3,0x0f,0x2f,0xc1,0x77,0x05,0x0f,0x28,0xd1,0xeb,0xdc,0x66,0x0f,
	0xef,0xd2,0x0f,0x2f,0xca,0x77,0xf2,0xb8,0x00,0x00,0x7f,0x43,0x66,
	0x0f,0x6e,0xc0,0x48,0x89,0xec,0x5d,0xc3,0x66,0x0f,0xef,0xc9,0x0f,
	0x2f,0xd1,0x77,0xbc,0xeb,0xe7,0x55,0x48,0x89,0xe5,0x48,0x83,0xe4,
	0xf0,0x48,0x83,0xec,0x20,0x89,0xcf,0x89,0xd6,0x89,0x7d,0xe4,0x89,
	0x75,0xe0,0xb8,0x00,0x00,0xb4,0x43,0xbf,0x00,0x00,0x70,0x42,0xbe,
	0x00,0x00,0xa0,0x40,0x66,0x0f,0xef,0xc0,0xf3,0x0f,0x2a,0x45,0xe0,
	0x66,0x0f,0xef,0xd2,0xf3,0x0f,0x2a,0x55,0xe4,0x0f,0x28,0xc8,0xf3,
	0x0f,0x5e,0xca,0x66,0x0f,0x6e,0xc0,0xf3,0x0f,0x59,0xc1,0xf3,0x0f,
	0x11,0x45,0xec,0x66,0x0f,0x6e,0xcf,0xf3,0x0f,0x5e,0xc1,0xf3,0x0f,
	0x11,0x45,0xf0,0xc6,0x45,0xf4,0x00,0xf3,0x0f,0x10,0x45,0xf0,0x0f,
	0x28,0xc8,0x66,0x0f,0x6e,0xc6,0xe8,0x0c,0xff,0xff,0xff,0xb9,0x00,
	0x00,0x40,0x40,0xf3,0x0f,0x2c,0xc0,0x0f,0xb6,0xc0,0x09,0x45,0xf4,
	0xf3,0x0f,0x10,0x45,0xf0,0x0f,0x28,0xc8,0x66,0x0f,0x6e,0xc1,0xe8,
	0xec,0xfe,0xff,0xff,0xf3,0x0f,0x2c,0xf8,0x40,0x0f,0xb6,0xd7,0xb8,
	0x00,0x00,0x80,0x3f,0xc1,0xe2,0x08,0x09,0x55,0xf4,0xf3,0x0f,0x10,
	0x45,0xf0,0x0f,0x28,0xc8,0x66,0x0f,0x6e,0xc0,0xe8,0xc8,0xfe,0xff,
	0xff,0xf3,0x0f,0x2c,0xf0,0x40,0x0f,0xb6,0xce,0xc1,0xe1,0x10,0x09,
	0x4d,0xf4,0x8b,0x45,0xf4,0x48,0x89,0xec,0x5d,0xc3,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x0d,0x0a,0x00,0x41,0x77,0x6f,0x6f,0x6f,0x6f,0x6f,0x6f,0x6f,0x6f,
	0x6f,0x6f,0x6f,0x6f,0x67,0x61,0x0d,0x0a,0x00,0x1b,0x5b,0x33,0x38,
	0x3b,0x32,0x3b,0x3b,0x6d,0x1b,0x5b,0x30,0x6d,0xf0,0x9f,0xa6,0x80,
	0x00,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,
	0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,
	0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,
	0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,
	0x7e,0x7e,0x7e,0x7e,0x0d,0x0a,0x00,0x52,0x75,0x73,0x74,0x20,0x69,
	0x73,0x20,0x61,0x20,0x6d,0x61,0x6e,0x79,0x2d,0x73,0x70,0x6c,0x65,
	0x6e,0x64,0x6f,0x72,0x65,0x64,0x20,0x74,0x68,0x69,0x6e,0x67,0x0a,
	0x49,0x74,0x27,0x73,0x20,0x74,0x68,0x65,0x20,0x41,0x70,0x72,0x69,
	0x6c,0x20,0x72,0x6f,0x73,0x65,0x20,0x74,0x68,0x61,0x74,0x20,0x6f,
	0x6e,0x6c,0x79,0x20,0x67,0x72,0x6f,0x77,0x73,0x20,0x69,0x6e,0x20,
	0x74,0x68,0x65,0x20,0x65,0x61,0x72,0x6c,0x79,0x20,0x73,0x70,0x72,
	0x69,0x6e,0x67,0x0a,0x52,0x75,0x73,0x74,0x20,0x69,0x73,0x20,0x6e,
	0x61,0x74,0x75,0x72,0x65,0x27,0x73,0x20,0x77,0x61,0x79,0x20,0x6f,
	0x66,0x20,0x67,0x69,0x76,0x69,0x6e,0x67,0x0a,0x41,0x20,0x72,0x65,
	0x61,0x73,0x6f,0x6e,0x20,0x74,0x6f,0x20,0x62,0x65,0x20,0x6c,0x69,
	0x76,0x69,0x6e,0x67,0x0a,0x54,0x68,0x65,0x20,0x62,0x6f,0x72,0x72,
	0x6f,0x77,0x20,0x63,0x68,0x65,0x63,0x6b,0x65,0x72,0x20,0x6d,0x61,
	0x6b,0x65,0x73,0x20,0x61,0x20,0x6d,0x61,0x6e,0x20,0x61,0x20,0x6b,
	0x69,0x6e,0x67,0x0a,0x00,0x90,0x90
	];

/*
	CVE-RS (https://github.com/Speykious/cve-rs) below
*/

/// This function, on its own, is sound:
/// - `_val_a`'s lifetime is `&'a &'b`. This means that `'b` must outlive `'a`, so
///   that the `'a` reference is never dangling. If `'a` outlived `'b` then it could
///   borrow data that's already been dropped.
/// - Therefore, `val_b`, which has a lifetime of `'b`, is valid for `'a`.
#[inline(never)]
pub const fn lifetime_translator<'a, 'b, T: ?Sized>(_val_a: &'a &'b (), val_b: &'b T) -> &'a T {
    val_b
}

/// This does the same thing as [`lifetime_translator`], just for mutable refs.
#[inline(never)]
pub fn lifetime_translator_mut<'a, 'b, T: ?Sized>(
    _val_a: &'a &'b (),
    val_b: &'b mut T,
) -> &'a mut T {
    val_b
}

/// Expands the domain of `'a` to `'b`.
///
/// # Safety
///
/// Safety? What's that?
pub fn expand<'a, 'b, T: ?Sized>(x: &'a T) -> &'b T {
    let f: for<'x> fn(_, &'x T) -> &'b T = lifetime_translator;
    f(STATIC_UNIT, x)
}

/// This does the same thing as [`expand`] for mutable references.
///
/// # Safety
///
/// Safety? What's that?
pub fn expand_mut<'a, 'b, T: ?Sized>(x: &'a mut T) -> &'b mut T {
    let f: for<'x> fn(_, &'x mut T) -> &'b mut T = lifetime_translator_mut;
    f(STATIC_UNIT, x)
}

/// A unit with a static lifetime.
///
/// Thanks to the soundness hole, this lets us cast any value all the way up to
/// a `'static` lifetime, meaning any lifetime we want.
pub const STATIC_UNIT: &&() = &&();

pub fn transmute<A, B>(obj: A) -> B {
    use std::hint::black_box;

    // The layout of `DummyEnum` is approximately
    // DummyEnum {
    //     is_a_or_b: u8,
    //     data: usize,
    // }
    // Note that `data` is shared between `DummyEnum::A` and `DummyEnum::B`.
    // This should hopefully be more reliable than spamming the stack with a value and hoping the memory
    // is placed correctly by the compiler.
    #[allow(dead_code)]
    enum DummyEnum<A, B> {
        A(Option<Box<A>>),
        B(Option<Box<B>>),
    }

    #[inline(never)]
    fn transmute_inner<A, B>(dummy: &mut DummyEnum<A, B>, obj: A) -> B {
        let DummyEnum::B(ref_to_b) = dummy else {
            unreachable!()
        };
        let ref_to_b = expand_mut(ref_to_b);
        *dummy = DummyEnum::A(Some(Box::new(obj)));
        black_box(dummy);

        *ref_to_b.take().unwrap()
    }

    transmute_inner(black_box(&mut DummyEnum::B(None)), obj)
}
