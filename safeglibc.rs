#![forbid(unsafe_code)]

// All fn code not main() or safely_get_fnaddr_from_got() is from
// cve-rs (https://github.com/Speykious/cve-rs), which uses a
// "soundness" issue in Rust (known since 2015) that
// allows for type punning actually less strict than C's.

// I have put what I needed from cve-rs all in this one file to
// emphasize that only nominally "safe" Rust (i.e. Rust without
// any `unsafe` statements/blocks or std::ffi use) is needed to gain
// arbitrary access to glibc (and a few Linux API) functions,
// pointer arithmetic, and anything C can do.

/// This function, on its own, is sound:
/// - `_val_a`'s lifetime is `&'a &'b`. This means that `'b` must outlive `'a`, so
///   that the `'a` reference is never dangling. If `'a` outlived `'b` then it could
///   borrow data that's already been dropped.
/// - Therefore, `val_b`, which has a lifetime of `'b`, is valid for `'a`.
#[inline(never)]
pub const fn lifetime_translator<'a, 'b, T: ?Sized>(_val_a: &'a &'b (), val_b: &'b T) -> &'a T {
    val_b
}

/// This does the same thing as [`lifetime_translator`], just for mutable refs.
#[inline(never)]
pub fn lifetime_translator_mut<'a, 'b, T: ?Sized>(
    _val_a: &'a &'b (),
    val_b: &'b mut T,
) -> &'a mut T {
    val_b
}

/// Expands the domain of `'a` to `'b`.
///
/// # Safety
///
/// Safety? What's that?
pub fn expand<'a, 'b, T: ?Sized>(x: &'a T) -> &'b T {
    let f: for<'x> fn(_, &'x T) -> &'b T = lifetime_translator;
    f(STATIC_UNIT, x)
}

/// This does the same thing as [`expand`] for mutable references.
///
/// # Safety
///
/// Safety? What's that?
pub fn expand_mut<'a, 'b, T: ?Sized>(x: &'a mut T) -> &'b mut T {
    let f: for<'x> fn(_, &'x mut T) -> &'b mut T = lifetime_translator_mut;
    f(STATIC_UNIT, x)
}

/// A unit with a static lifetime.
///
/// Thanks to the soundness hole, this lets us cast any value all the way up to
/// a `'static` lifetime, meaning any lifetime we want.
pub const STATIC_UNIT: &&() = &&();

pub fn transmute<A, B>(obj: A) -> B {
    use std::hint::black_box;

    // The layout of `DummyEnum` is approximately
    // DummyEnum {
    //     is_a_or_b: u8,
    //     data: usize,
    // }
    // Note that `data` is shared between `DummyEnum::A` and `DummyEnum::B`.
    // This should hopefully be more reliable than spamming the stack with a value and hoping the memory
    // is placed correctly by the compiler.
    #[allow(dead_code)]
    enum DummyEnum<A, B> {
        A(Option<Box<A>>),
        B(Option<Box<B>>),
    }

    #[inline(never)]
    fn transmute_inner<A, B>(dummy: &mut DummyEnum<A, B>, obj: A) -> B {
        let DummyEnum::B(ref_to_b) = dummy else {
            unreachable!()
        };
        let ref_to_b = expand_mut(ref_to_b);
        *dummy = DummyEnum::A(Some(Box::new(obj)));
        black_box(dummy);

        *ref_to_b.take().unwrap()
    }

    transmute_inner(black_box(&mut DummyEnum::B(None)), obj)
}

/// This function works only with JMP/CALL instructions
/// which have an encoded 4 byte offset and probably only with
/// x86_64 ELF bins. The PLT stubs would obv be irrelevant to PE bins
fn safely_get_fnaddr_from_got<FnType>(needle: &[u8]) -> Option<FnType> {
    let mainaddr = transmute::<fn() -> (), usize>(main);
    let mem = transmute::<usize, &[u8; u32::MAX as usize]>(mainaddr);

    if let Some(position) = mem
        .windows(needle.len())
        .position(|window| window == needle)
    {
        let plt_offset_offset: usize = position + needle.len();
        let offsetslice = &mem[plt_offset_offset..plt_offset_offset + 4];

        let signed_offset: i32 = (offsetslice[0] as i32)
            | (offsetslice[1] as i32) << (1 << 3)
            | (offsetslice[2] as i32) << (2 << 3)
            | (offsetslice[3] as i32) << (3 << 3);

        //The 4-byte offset encoded in the CALL opcode is relative to the next instruction's address
        let next_op_addr: usize = mainaddr + plt_offset_offset + 4;
        let call_addr_operand_addr: usize = (signed_offset as i64 + next_op_addr as i64) as usize;
        let got_entry_addr = transmute::<usize, &[u8; 8]>(call_addr_operand_addr);
        let target_be: usize = usize::from_le_bytes(*got_entry_addr);

        let safe_fn = transmute::<usize, FnType>(target_be);

        return Some(safe_fn);
    } else {
        println!("PLT stub not found!");
    }
    None
}

/// Safely get safe versions of C stdlib memset, malloc, and free by searching
/// instruction memory for PLT stubs that have opcodes with the GOT addresses encoded.
/// This is non-portable but works for the debug and release x86_64 ELF binaries
/// generated by whatever versions of glibc and rustc are on my machine.
fn main() {
    // This is not shellcode, but the contents of the PLT stubs which
    // call these functions. Their JMP and CALL instructions have, encoded,
    // the addresses of their functions' GOT entries, at which there are
    // stored the actual callable addresses. These are populated at load.

    use std::hint::black_box;
    let memset_stub = black_box(&[0x4c, 0x89, 0xf7, 0x31, 0xf6, 0x48, 0x89, 0xda, 0xff, 0x15]);
    let malloc_stub = black_box(&[0x48, 0x89, 0xd7, 0xff, 0x25]);
    let free_stub = black_box(&[0x4c, 0x89, 0xf7, 0xff, 0x15]);
    let mmap64_stub = black_box(&[0x45, 0x89, 0xf0, 0x45, 0x31, 0xc9, 0xff, 0x15]);
    let munmap_stub = black_box(&[0x4c, 0x89, 0xef, 0x4c, 0x89, 0xe6, 0xff, 0x15]);
    let syscall_stub = black_box(&[
        0xbf, 0x4c, 0x01, 0x00, 0x00, 0x41, 0xb8, 0xff, 0x0f, 0x00, 0x00, 0x31, 0xc0, 0xff, 0x15,
    ]);

    let mainaddr = transmute::<fn() -> (), usize>(main);
    let mem = transmute::<usize, &[u8; u32::MAX as usize]>(mainaddr);
    let retbyte : u8 = 0xc3;

    if let Some(position) = (*mem)
        .iter()
        .position(|&v| v == retbyte)
    {
		println!("Machine code of fn main():");
		for idx in 0..position + 1
		{
			print!("0x{:x}{}", mem[idx], if idx < position
			{","} else {"\n"});
		}
	}
	else
	{
		
	}
    let safe_memset = match safely_get_fnaddr_from_got::<fn(usize, i32, usize)>(memset_stub) {
        Some(val) => val,
        None => {
            println!("Could not find memset");
            return;
        }
    };

    let safe_malloc = match safely_get_fnaddr_from_got::<fn(usize) -> usize>(malloc_stub) {
        Some(val) => val,
        None => {
            println!("Could not find malloc");
            return;
        }
    };

    let safe_free = match safely_get_fnaddr_from_got::<fn(usize) -> ()>(free_stub) {
        Some(val) => val,
        None => {
            println!("Could not find free");
            return;
        }
    };

    let safe_mmap64 = match safely_get_fnaddr_from_got::<
        fn(usize, usize, i32, i32, i32, isize) -> isize,
    >(mmap64_stub)
    {
        Some(val) => val,
        None => {
            println!("Could not find mmap64");
            return;
        }
    };

    let safe_munmap = match safely_get_fnaddr_from_got::<fn(usize, usize) -> i32>(munmap_stub) {
        Some(val) => val,
        None => {
            println!("Could not find munmap");
            return;
        }
    };

    let safe_syscall = match safely_get_fnaddr_from_got::<fn() -> ()>(syscall_stub) {
        Some(val) => val,
        None => {
            println!("Could not find munmap");
            return;
        }
    };

    let strv: &[u8] = "\nThis message brought to you by syscall()\n".as_bytes();
    let pstrv: usize = transmute::<&[u8], usize>(strv);

    transmute::<fn() -> (), fn(u32, u32, usize, u32) -> i32>(safe_syscall)(
        1_u32,
        1_u32,
        pstrv,
        strv.len() as u32,
    );

    let pheapmem = safe_malloc(64);
    let heapslice = transmute::<usize, &mut [u8; 64]>(pheapmem);

    println!("\nContents of memory block allocated by malloc():");
    for idx in 0..64 {
        print!(
            "0x{:x}{}",
            heapslice[idx],
            if idx == 63 { "\n" } else { "," }
        );
    }

    safe_memset(pheapmem, 0x42, 64);

    println!("\nHeap contents after memset:");
    for idx in 0..64 {
        print!(
            "0x{:x}{}",
            heapslice[idx],
            if idx == 63 { "\n" } else { "," }
        );
        heapslice[idx] = ((idx << 1) & 255) as u8;
    }

    println!("\nHeap contents after writing:");
    for idx in 0..64 {
        print!(
            "0x{:x}{}",
            heapslice[idx],
            if idx == 63 { "\n" } else { "," }
        );
    }

    safe_free(pheapmem);
    print!("\n");

    let rval = safe_mmap64(0, 0x0D00, 7, 34, -1, 0);

    if rval < 0 {
        println!("safe_mmap64 failed.");
    } else {
        let quote_shellcode_unquote: &[u8] = &[
	0x52,0x57,0x55,0x53,0x48,0x89,0xe5,0x48,0x8d,0x3d,0xb6,0x03,0x00,
	0x00,0xe8,0x21,0x00,0x00,0x00,0x48,0x89,0xc6,0x48,0x8d,0x3d,0xa7,
	0x03,0x00,0x00,0xe8,0x33,0x00,0x00,0x00,0xe8,0xd1,0x00,0x00,0x00,
	0xe8,0xec,0x01,0x00,0x00,0x48,0x89,0xec,0x5b,0x5d,0x5f,0x5a,0xc3,
	0x53,0x51,0x48,0x31,0xc0,0x48,0x31,0xdb,0x48,0x8d,0x0f,0x8a,0x19,
	0x48,0x83,0xc1,0x01,0x48,0x83,0xc0,0x01,0x80,0xfb,0x00,0x75,0xf1,
	0x48,0x83,0xe8,0x01,0x59,0x5b,0xc3,0x51,0x50,0x41,0x50,0x41,0x51,
	0x41,0x52,0x41,0x53,0x41,0x54,0x41,0x55,0x41,0x56,0x49,0x89,0xf8,
	0x49,0x89,0xf1,0x48,0x31,0xc9,0x4d,0x31,0xd2,0x4d,0x31,0xed,0x4d,
	0x31,0xe4,0x41,0xbe,0x50,0x00,0x00,0x00,0x4c,0x39,0xf6,0x7d,0x03,
	0x49,0x89,0xf6,0x4c,0x89,0xee,0x4c,0x89,0xf7,0xe8,0x43,0x02,0x00,
	0x00,0x49,0x89,0xc2,0x49,0x81,0xe2,0xff,0x00,0x00,0x00,0x49,0x89,
	0xc3,0x49,0xc1,0xeb,0x08,0x49,0x81,0xe3,0xff,0x00,0x00,0x00,0x48,
	0x89,0xc3,0x48,0xc1,0xeb,0x10,0x48,0x81,0xe3,0xff,0x00,0x00,0x00,
	0x49,0x8d,0x00,0x4c,0x01,0xe0,0x48,0x31,0xff,0x40,0x8a,0x38,0x4c,
	0x89,0xd6,0x4c,0x89,0xda,0x48,0x89,0xd9,0xe8,0x3e,0x00,0x00,0x00,
	0x49,0x83,0xc4,0x01,0x4d,0x39,0xcc,0x7d,0x0e,0x49,0x83,0xc5,0x01,
	0x49,0x83,0xfd,0x51,0x7c,0xa2,0x31,0xc9,0xeb,0x9e,0x41,0x5e,0x41,
	0x5d,0x41,0x5c,0x41,0x5b,0x41,0x5a,0x41,0x59,0x41,0x58,0x58,0x59,
	0xc3,0x57,0x56,0x48,0x8d,0x3d,0xbf,0x02,0x00,0x00,0xbe,0x04,0x00,
	0x00,0x00,0xe8,0xea,0x00,0x00,0x00,0x5e,0x5f,0xc3,0x50,0x53,0x51,
	0x41,0x50,0x41,0x51,0x41,0x52,0x41,0x53,0x41,0x54,0x41,0x55,0x55,
	0x48,0x89,0xe5,0x49,0x89,0xf8,0x49,0x89,0xf1,0x49,0x89,0xd2,0x49,
	0x89,0xcb,0xbe,0x07,0x00,0x00,0x00,0x48,0x8d,0x3d,0x7e,0x02,0x00,
	0x00,0xe8,0xb7,0x00,0x00,0x00,0x4c,0x89,0xcf,0xe8,0x5f,0x00,0x00,
	0x00,0xbe,0x01,0x00,0x00,0x00,0x48,0x8d,0x3d,0x6c,0x02,0x00,0x00,
	0xe8,0x9e,0x00,0x00,0x00,0x4c,0x89,0xd7,0xe8,0x46,0x00,0x00,0x00,
	0xbe,0x01,0x00,0x00,0x00,0x48,0x8d,0x3d,0x53,0x02,0x00,0x00,0xe8,
	0x85,0x00,0x00,0x00,0x4c,0x89,0xdf,0xe8,0x2d,0x00,0x00,0x00,0xbe,
	0x01,0x00,0x00,0x00,0x48,0x8d,0x3d,0x3b,0x02,0x00,0x00,0xe8,0x6c,
	0x00,0x00,0x00,0x4c,0x89,0xc7,0xe8,0x43,0x00,0x00,0x00,0x48,0x89,
	0xec,0x5d,0x41,0x5d,0x41,0x5c,0x41,0x5b,0x41,0x5a,0x41,0x59,0x41,
	0x58,0x59,0x5b,0x58,0xc3,0x41,0x53,0x50,0x56,0x53,0x55,0x48,0x89,
	0xe5,0x48,0x83,0xec,0x20,0x48,0x8d,0x75,0xff,0xe8,0xd2,0x01,0x00,
	0x00,0x48,0x8d,0x75,0x00,0x48,0x29,0xc6,0x48,0x89,0xc7,0xe8,0x2b,
	0x00,0x00,0x00,0x48,0x89,0xec,0x5d,0x5b,0x5e,0x58,0x41,0x5b,0xc3,
	0x56,0x55,0x48,0x89,0xe5,0x48,0x83,0xec,0x08,0x40,0x88,0x7d,0xf8,
	0x48,0x8d,0x7d,0xf8,0xbe,0x01,0x00,0x00,0x00,0xe8,0x06,0x00,0x00,
	0x00,0x48,0x89,0xec,0x5d,0x5e,0xc3,0x41,0x53,0x52,0x50,0x55,0x48,
	0x89,0xe5,0x48,0x89,0xf2,0x48,0x89,0xfe,0xb8,0x01,0x00,0x00,0x00,
	0xbf,0x01,0x00,0x00,0x00,0x0f,0x05,0x48,0x89,0xec,0x5d,0x58,0x5a,
	0x41,0x5b,0xc3,0x57,0x52,0x56,0x55,0x48,0x89,0xe5,0x48,0x83,0xec,
	0x08,0xb8,0x01,0x00,0x00,0x00,0xbf,0x01,0x00,0x00,0x00,0xba,0x01,
	0x00,0x00,0x00,0xc6,0x45,0xf8,0x0a,0x48,0x8d,0x75,0xf8,0x0f,0x05,
	0x48,0x89,0xec,0x5d,0x5e,0x5a,0x5f,0xc3,0x0f,0x28,0xd0,0xf3,0x0f,
	0x5e,0xd1,0xf3,0x0f,0x2c,0xc2,0x66,0x0f,0xef,0xd2,0xf3,0x0f,0x2a,
	0xd0,0xf3,0x0f,0x59,0xca,0xf3,0x0f,0x5c,0xc1,0xc3,0xf3,0x0f,0x58,
	0xc1,0xb8,0x00,0x00,0xc0,0x40,0x66,0x0f,0x6e,0xc8,0xe8,0xd2,0xff,
	0xff,0xff,0xb8,0x00,0x00,0x80,0x40,0x66,0x0f,0x6e,0xc8,0x0f,0x28,
	0xd0,0xf3,0x0f,0x5c,0xc8,0xb8,0x00,0x00,0x80,0x3f,0x66,0x0f,0x6e,
	0xc0,0x0f,0x2f,0xca,0x76,0x1b,0x0f,0x2f,0xc2,0x77,0x33,0xf3,0x0f,
	0x5d,0xd0,0xf3,0x0f,0x5c,0xc2,0xb8,0x00,0x00,0x7f,0x43,0x66,0x0f,
	0x6e,0xd8,0xf3,0x0f,0x59,0xc3,0xc3,0x0f,0x2f,0xc1,0x77,0x05,0x0f,
	0x28,0xd1,0xeb,0xe0,0x66,0x0f,0xef,0xd2,0x0f,0x2f,0xca,0x77,0xf2,
	0xb8,0x00,0x00,0x7f,0x43,0x66,0x0f,0x6e,0xc0,0xc3,0x66,0x0f,0xef,
	0xc9,0x0f,0x2f,0xd1,0x77,0xc4,0xeb,0xeb,0x55,0x48,0x89,0xe5,0x48,
	0x83,0xec,0x18,0x89,0x7d,0xe4,0x89,0x75,0xe0,0x66,0x0f,0xef,0xc0,
	0xf3,0x0f,0x2a,0x45,0xe0,0x66,0x0f,0xef,0xd2,0xf3,0x0f,0x2a,0x55,
	0xe4,0x0f,0x28,0xc8,0xf3,0x0f,0x5e,0xca,0xb8,0x00,0x00,0xb4,0x43,
	0x66,0x0f,0x6e,0xc0,0xf3,0x0f,0x59,0xc1,0xf3,0x0f,0x11,0x45,0xec,
	0xb8,0x00,0x00,0x70,0x42,0x66,0x0f,0x6e,0xc8,0xf3,0x0f,0x5e,0xc1,
	0xf3,0x0f,0x11,0x45,0xf0,0xc6,0x45,0xf4,0x00,0xf3,0x0f,0x10,0x45,
	0xf0,0x0f,0x28,0xc8,0xb8,0x00,0x00,0xa0,0x40,0x66,0x0f,0x6e,0xc0,
	0xe8,0x28,0xff,0xff,0xff,0xf3,0x0f,0x2c,0xc0,0x0f,0xb6,0xc0,0x09,
	0x45,0xf4,0xf3,0x0f,0x10,0x45,0xf0,0x0f,0x28,0xc8,0xb8,0x00,0x00,
	0x40,0x40,0x66,0x0f,0x6e,0xc0,0xe8,0x08,0xff,0xff,0xff,0xf3,0x0f,
	0x2c,0xc0,0x0f,0xb6,0xc0,0xc1,0xe0,0x08,0x09,0x45,0xf4,0xf3,0x0f,
	0x10,0x45,0xf0,0x0f,0x28,0xc8,0xb8,0x00,0x00,0x80,0x3f,0x66,0x0f,
	0x6e,0xc0,0xe8,0xe5,0xfe,0xff,0xff,0xf3,0x0f,0x2c,0xc0,0x0f,0xb6,
	0xc0,0xc1,0xe0,0x10,0x09,0x45,0xf4,0x8b,0x45,0xf4,0xc9,0xc3,0x51,
	0x52,0x53,0x57,0xbb,0x0a,0x00,0x00,0x00,0x89,0xf8,0x31,0xd2,0xf7,
	0xf3,0x89,0xc1,0x83,0xc2,0x30,0x88,0x16,0x48,0x83,0xee,0x01,0x85,
	0xc0,0x75,0xed,0x48,0x89,0xf0,0x48,0x83,0xc0,0x01,0x5f,0x5b,0x5a,
	0x59,0xc3,0x1b,0x5b,0x33,0x38,0x3b,0x32,0x3b,0x3b,0x6d,0x1b,0x5b,
	0x30,0x6d,0x52,0x75,0x73,0x74,0x20,0x70,0x72,0x6f,0x76,0x69,0x64,
	0x65,0x73,0x20,0x61,0x20,0x63,0x6f,0x6d,0x70,0x6c,0x65,0x74,0x65,
	0x20,0x6d,0x65,0x6d,0x6f,0x72,0x79,0x20,0x73,0x61,0x66,0x65,0x74,
	0x79,0x20,0x67,0x75,0x61,0x72,0x61,0x6e,0x74,0x65,0x65,0x2c,0x20,
	0x65,0x78,0x63,0x65,0x70,0x74,0x20,0x69,0x6e,0x0a,0x75,0x6e,0x73,
	0x61,0x66,0x65,0x2e,0x20,0x54,0x68,0x69,0x73,0x20,0x70,0x72,0x6f,
	0x67,0x72,0x61,0x6d,0x20,0x68,0x61,0x73,0x20,0x6e,0x6f,0x20,0x75,
	0x6e,0x73,0x61,0x66,0x65,0x5f,0x63,0x6f,0x64,0x65,0x2c,0x20,0x74,
	0x68,0x65,0x72,0x65,0x66,0x6f,0x72,0x65,0x20,0x74,0x68,0x69,0x73,
	0x20,0x69,0x73,0x20,0x6e,0x6f,0x74,0x20,0x70,0x6f,0x73,0x73,0x69,
	0x62,0x6c,0x65,0x3a,0x0a,0x00,0x90

        ];
        println!("Loading machine code from &[u8] to 0x{:x} mmap64 returned rwx\n", rval);

        let rwxmem = transmute::<isize, &mut [u8; 0x0D00]>(rval);
        for idx in 0..quote_shellcode_unquote.len() {
            rwxmem[idx] = quote_shellcode_unquote[idx];
        }
        
        println!("Running machine code loaded from &[u8] now.");
        
        let entirely_safe_function = transmute::<&mut [u8], fn() -> ()>(rwxmem);
        entirely_safe_function();

        let munmap_result = safe_munmap(rval as usize, 0x0D00);
        if munmap_result < 0 {
            println!("munmap() failed");
        }
        
        let y = transmute::<usize, &i32>(0);
        println!("{}", *y);
        
    }
   
	
}
