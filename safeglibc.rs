#![forbid(unsafe_code)]

// Uses transmute::<A,B>(obj) from cve-rs (https://github.com/Speykious/cve-rs),
// which abuses a soundness issue in Rust (known since 2015) related to 
// lifetime contravariance to somehow chain its way into unrestricted type punning.

// I have put what I needed from cve-rs all in this one file to
// emphasize that only nominally "safe" Rust (i.e. Rust without
// any `unsafe` statements/blocks or std::ffi use) is needed to gain
// arbitrary access to glibc functions imported by the Rust stdlib,
// do pointer arithmetic, and anything else C can do.

/// This function works only with JMP/CALL instructions
/// which have an encoded 4 byte offset. You pass a sequence of bytes in
/// or near a function that calls the function you're looking for,
/// adjusting with offset_from_needle as necessary. A bit fragile

fn safely_get_fnaddrval_from_got(startaddr : usize, needle: &[u8], offset_from_needle: usize) -> usize {
	
	/* "... This is beyond what C++ and C# enums can do. It's more like a 
		C union -- but unlike unions, Rust enums are type-safe."
	- Programming Rust, page 211 */
    
    let mem = transmute::<usize, &[u8; u32::MAX as usize]>(startaddr);

    if let Some(position) = mem
        .windows(needle.len())
        .position(|window| window == needle)
    {
        let plt_offset_offset: usize = offset_from_needle + position + needle.len();

        let offsetslice = transmute::<&[u8], &i32>(&mem[plt_offset_offset..plt_offset_offset + 4]);
		let signed_offset : i32 = *offsetslice;

        //The 4-byte offset encoded in the CALL opcode is relative to the next instruction's address
        let next_op_addr: usize = startaddr + plt_offset_offset + 4;
        let call_addr_operand_addr: usize = (signed_offset as i64 + next_op_addr as i64) as usize;
        let got_entry_addr = transmute::<usize, &[u8; 8]>(call_addr_operand_addr);
        let target_be: usize = usize::from_le_bytes(*got_entry_addr);

        return target_be;
    }
    
    return 0;
}

struct LinuxLibs {
    pmalloc: usize,
    pfree: usize,
    pmemcpy: usize,
    pmemset: usize,
    pmmap64: usize,
    pmunmap: usize,
    psyscall: usize,
    pdl_iterate_phdr: usize,
}

#[allow(unused)]
struct MapEntry {
	address_start: usize,
	address_end: usize,
	permissions: String,
	offset: usize,
	device_inode: String,
	pathname: String,
}

impl LinuxLibs {
	

		
    fn malloc(&self, size: usize) -> usize {
        let tmpmalloc = transmute::<usize, fn(usize) -> usize>(self.pmalloc);
        tmpmalloc(size)
    }
    fn free(&self, ptr: usize) {
        let tmpfree = transmute::<usize, fn(usize) -> ()>(self.pfree);
        tmpfree(ptr);
    }

    fn memset(&self, ptr: usize, val: i32, count: usize) -> usize {
        transmute::<usize, fn(usize, i32, usize) -> usize>(self.pmemset)(ptr, val, count)
    }

    fn memcpy(&self, dest: usize, src: usize, count: usize) -> usize {
        let tmpmemcpy = transmute::<usize, fn(usize, usize, usize) -> usize>(self.pmemcpy);
        tmpmemcpy(dest, src, count)
    }

    fn mmap64(
        &self,
        paddr: usize,
        length: usize,
        prot: i32,
        flags: i32,
        fd: i32,
        offset: isize,
    ) -> isize {
        let tmpmmap64 =
            transmute::<usize, fn(usize, usize, i32, i32, i32, isize) -> isize>(self.pmmap64);
        tmpmmap64(paddr, length, prot, flags, fd, offset)
    }

    fn munmap(&self, ptr: usize, size: usize) -> i32 {
        let tmpmunmap = transmute::<usize, fn(usize, usize) -> i32>(self.pmunmap);
        tmpmunmap(ptr, size)
    }

    fn dl_iterate_phdr(&self, callback: usize, pdata: usize) -> i32 {
        transmute::<usize, fn(usize, usize) -> i32>(self.pdl_iterate_phdr)(callback, pdata)
    }

    fn initialize(&mut self) {
		
		LinuxLibs::check_elf_header();

		let mainaddr = transmute::<fn()->(), usize>(main);
		
		let path = std::env::current_exe().unwrap();
		let procmap_entries_opt = LinuxLibs::parse_procmap();
		
		if procmap_entries_opt.is_none()
		{
			println!("Couldn't parse procmap entries. That's ok; we don't use them.");
		}
		else
		{
			let map_entries = procmap_entries_opt.unwrap();
			let progentries : Vec<&MapEntry> = map_entries.iter().filter(
				|entry| { entry.pathname == path }
			).collect();
			
			assert!(progentries.len() > 0, "Found no entries for program in proc map");
			let progaddrstart = progentries[0].address_start;
			let progaddrend = progentries[progentries.len() - 1].address_end;
			println!("Program start: 0x{:x} End: 0x{:x}", progaddrstart, progaddrend);
			println!("Main addr: 0x{:x}", mainaddr);
		}
		
        use std::hint::black_box;
        let memset_stub = black_box(&[0x4c, 0x89, 0xf7, 0x31, 0xf6, 0x48, 0x89, 0xda, 0xff, 0x15]);
        let malloc_stub = black_box(&[0x48, 0x89, 0xd7, 0xff, 0x25]);
        let free_stub = black_box(&[
            0x48, 0x89, 0xc7, 0x4c, 0x89, 0xf6, 0x48, 0x89, 0xda, 0x48, 0x89, 0xc3, 0xff, 0x15,
        ]);
        let memcpy_stub = black_box(&[
            0x49, 0x8b, 0x7e, 0x08, 0x4c, 0x01, 0xff, 0x48, 0x89, 0xda, 0xff, 0x15,
        ]);
        let mmap64_stub = black_box(&[0x45, 0x89, 0xf0, 0x45, 0x31, 0xc9, 0xff, 0x15]);
        let munmap_stub = black_box(&[0x4c, 0x89, 0xef, 0x4c, 0x89, 0xe6, 0xff, 0x15]);
        let syscall_stub = black_box(&[
            0xbf, 0x4c, 0x01, 0x00, 0x00, 0x41, 0xb8, 0xff, 0x0f, 0x00, 0x00, 0x31, 0xc0, 0xff,
            0x15,
        ]);
        let dl_iterate_phdr_stub = black_box(&[
            0x4d, 0x89, 0x7e, 0x18, 0x4d, 0x89, 0x66, 0x20, 0x49, 0x89, 0x5e, 0x28,
        ]);

        self.pmemset = safely_get_fnaddrval_from_got(mainaddr, memset_stub, 0);
        self.pmalloc = safely_get_fnaddrval_from_got(mainaddr, malloc_stub, 0);
        self.pfree = safely_get_fnaddrval_from_got(mainaddr, free_stub, 0x9);
        self.pmemcpy = safely_get_fnaddrval_from_got(mainaddr, memcpy_stub, 0);
        self.pmmap64 = safely_get_fnaddrval_from_got(mainaddr, mmap64_stub, 0);
        self.pmunmap = safely_get_fnaddrval_from_got(mainaddr, munmap_stub, 0);
        self.psyscall = safely_get_fnaddrval_from_got(mainaddr, syscall_stub, 0); //syscall is variadic
        self.pdl_iterate_phdr = safely_get_fnaddrval_from_got(mainaddr, dl_iterate_phdr_stub, 12);
    }

	fn parse_procmap() -> Option<Vec<MapEntry>>
	{
	    use std::io::prelude::*;	    
        let mut hprocmap = std::fs::File::open("/proc/self/maps").unwrap();
        let mut procmapstr : String = String::new();
        
		let _ = hprocmap.read_to_string(&mut procmapstr);
        
		let mut map_entries : Vec<MapEntry> = Vec::new();
		
        for line in procmapstr.lines()
        {
			let columns: Vec<&str> = line.split_whitespace().collect();
			
			// The line format must have at least 5 columns to be valid
			assert!(columns.len() >= 5, "Unexpected procmap row");

			// Parse the address range
			let (start_str, end_str) = columns[0].split_once('-')
				.expect("Address range format invalid");

			let address_start = usize::from_str_radix(start_str, 16).unwrap();
			let address_end = usize::from_str_radix(end_str, 16).unwrap();
			let offset = usize::from_str_radix(columns[2], 16).unwrap();

			// Handle optional pathname (column index 5)
			let pathname = columns.get(5).unwrap_or(&"[anonymous]").to_string();

			map_entries.push(
			MapEntry {
				address_start,
				address_end,
				permissions: columns[1].to_string(),
				offset,
				device_inode: columns[3].to_string(),
				pathname,
			});
		}
        
		Some(map_entries)
	}

    fn check_elf_header()
    {
        let path = std::env::current_exe().unwrap();
        let binbytes = std::fs::read(&path).unwrap();
        
        assert_eq!(&binbytes[0..4], &[0x7f, 0x45, 0x4c, 0x46],
                "This is not an ELF binary and the program will not work.");
        assert_eq!(*&binbytes[5], 1,
                "This program has an unexpected ELF File Class");
        assert_eq!(*&binbytes[6], 1,
                "This program has been compiled in big-endian mode somehow.\
                 This program will not work.");
        
        println!("Found ELF header.");
        print_byte_sequence(&binbytes[0..4]);
    }
    
    fn build_linuxlibs() -> LinuxLibs
    {
		let mut llibs = LinuxLibs {
			pmalloc: 0,
			pfree: 0,
			pmemcpy: 0,
			pmemset: 0,
			pmmap64: 0,
			pmunmap: 0,
			psyscall: 0,
			pdl_iterate_phdr: 0,
		};
		llibs.initialize();
		llibs
	}
}

fn addr_to_charptr(addr : usize) -> &'static [u8; u32::MAX as usize]
{
	transmute::<usize, &[u8; u32::MAX as usize]>(addr)
}

fn print_byte_sequence(bytes : &[u8])
{
	for idx in 0..bytes.len() {
        print!(
            "0x{:x}{}",
            bytes[idx],
            if idx == bytes.len() - 1 { "\n" } else { "," }
        );
    }
}

/// Safely get safe versions of C and Linux API lib functions by searching
/// instruction memory for PLT stubs that have opcodes with the GOT addresses encoded.
/// This is non-portable but works for the debug and release x86_64 ELF binaries
/// generated by whatever versions of glibc and rustc are on my machine.
fn main() {
    let retbyte: u8 = 0xc3;

    let llibs = LinuxLibs::build_linuxlibs();

    let mainaddr = transmute::<fn() -> (), usize>(main);
    let mem = addr_to_charptr(mainaddr);

    if let Some(position) = (*mem).iter().position(|&v| v == retbyte) {
        println!("Machine code of fn main():");
        print_byte_sequence(&mem[0..position + 1]);
    } else {
        println!("Couldn't find end of main()");
    }

    fn phdrinfo_callback(pinfo: usize, size: usize, pdata: usize) -> i32 {
        let llibs = transmute::<usize, &LinuxLibs>(pdata);
        let buffer: usize = llibs.malloc(size);
        if buffer == 0 {
            println!("Allocation error.");
            return 0;
        }
        llibs.memcpy(buffer, pinfo, size);
        
        let bufslice = addr_to_charptr(buffer);
        print_byte_sequence(&bufslice[0..size]);

        let rname = transmute::<usize, &usize>(buffer + 8);
        let pname = addr_to_charptr(*rname);
        let mut idx: usize = 0;
        let mut namebytes = Vec::new();
        while pname[idx] != 0 {
            namebytes.push(pname[idx]);
            idx = idx + 1;
        }
        println!("Object name: {}", String::from_utf8(namebytes).unwrap());
        llibs.free(buffer);
        return 0;
    }

    llibs.dl_iterate_phdr(
        transmute::<fn(usize, usize, usize) -> i32, usize>(phdrinfo_callback),
        transmute::<&LinuxLibs, usize>(&llibs),
    );

    let strv: &[u8] = "\nThis message brought to you by syscall()\n".as_bytes();
    let pstrv: usize = transmute::<&[u8], usize>(strv);

    //Use syscall to print to console
    let writetoconsole = transmute::<usize, fn(u32, u32, usize, u32) -> i32>(llibs.psyscall);
    writetoconsole(1_u32, 1_u32, pstrv, strv.len() as u32);

    let pheapmem = llibs.malloc(64);
    let heapslice = transmute::<usize, &mut [u8; 64]>(pheapmem);

    println!("\nContents of memory block allocated by malloc():");
    print_byte_sequence(heapslice);

    llibs.memset(pheapmem, 0x42, 64);

    println!("\nHeap contents after memset:");
    print_byte_sequence(heapslice);

    println!("\nHeap contents after writing:");
    print_byte_sequence(heapslice);

    print!("\n");
    llibs.free(pheapmem);

    // Call mmap64 to request a writable, executable block of memory
    // on the heap. We can copy machine code directly to that block
    // and transfer program control to it
    let rval = llibs.mmap64(0, 0x0D00, 7, 34, -1, 0);

    if rval < 0 {
        println!("safe_mmap64 failed.");
    } else {
        let machine_code: Vec<u8>;

        if cfg!(debug_assertions) {
            println!("Attempting to read sc.bin.");
            machine_code = match std::fs::read("sc.bin") {
                Ok(bytearr) => {
                    println!("Read sc.bin");
                    bytearr
                }
                Err(err) => {
                    println!("Could not read file: {}", err);
                    QUOTE_SHELLCODE_UNQUOTE.to_vec()
                }
            };
        } else {
            machine_code = QUOTE_SHELLCODE_UNQUOTE.to_vec();
        }

        println!("Loading machine code from &[u8] to 0x{:x}", rval);

        llibs.memcpy(rval as usize, 
			transmute::<&[u8], usize>(&(*machine_code)), 0x0D00);

        println!("Running machine code loaded from &[u8] now.");

        let entirely_safe_function = transmute::<isize, fn()-> i64>(rval);
        let returnvalue = entirely_safe_function();

        println!("Machine code return value: {:x}", returnvalue);

        let munmap_result = llibs.munmap(rval as usize, 0x0D00);
        if munmap_result < 0 {
            println!("munmap() failed");
        }
        else
        {
			println!("munmap() succeeded.");
		}
    }
}

/// This function, on its own, is sound:
/// - `_val_a`'s lifetime is `&'a &'b`. This means that `'b` must outlive `'a`, so
///   that the `'a` reference is never dangling. If `'a` outlived `'b` then it could
///   borrow data that's already been dropped.
/// - Therefore, `val_b`, which has a lifetime of `'b`, is valid for `'a`.
#[inline(never)]
pub const fn lifetime_translator<'a, 'b, T: ?Sized>(_val_a: &'a &'b (), val_b: &'b T) -> &'a T {
    val_b
}

/// This does the same thing as [`lifetime_translator`], just for mutable refs.
#[inline(never)]
pub fn lifetime_translator_mut<'a, 'b, T: ?Sized>(
    _val_a: &'a &'b (),
    val_b: &'b mut T,
) -> &'a mut T {
    val_b
}

/// Expands the domain of `'a` to `'b`.
///
/// # Safety
///
/// Safety? What's that?
pub fn expand<'a, 'b, T: ?Sized>(x: &'a T) -> &'b T {
    let f: for<'x> fn(_, &'x T) -> &'b T = lifetime_translator;
    f(STATIC_UNIT, x)
}

/// This does the same thing as [`expand`] for mutable references.
///
/// # Safety
///
/// Safety? What's that?
pub fn expand_mut<'a, 'b, T: ?Sized>(x: &'a mut T) -> &'b mut T {
    let f: for<'x> fn(_, &'x mut T) -> &'b mut T = lifetime_translator_mut;
    f(STATIC_UNIT, x)
}

/// A unit with a static lifetime.
///
/// Thanks to the soundness hole, this lets us cast any value all the way up to
/// a `'static` lifetime, meaning any lifetime we want.
pub const STATIC_UNIT: &&() = &&();

pub fn transmute<A, B>(obj: A) -> B {
    use std::hint::black_box;

    // The layout of `DummyEnum` is approximately
    // DummyEnum {
    //     is_a_or_b: u8,
    //     data: usize,
    // }
    // Note that `data` is shared between `DummyEnum::A` and `DummyEnum::B`.
    // This should hopefully be more reliable than spamming the stack with a value and hoping the memory
    // is placed correctly by the compiler.
    #[allow(dead_code)]
    enum DummyEnum<A, B> {
        A(Option<Box<A>>),
        B(Option<Box<B>>),
    }

    #[inline(never)]
    fn transmute_inner<A, B>(dummy: &mut DummyEnum<A, B>, obj: A) -> B {
        let DummyEnum::B(ref_to_b) = dummy else {
            unreachable!()
        };
        let ref_to_b = expand_mut(ref_to_b);
        *dummy = DummyEnum::A(Some(Box::new(obj)));
        black_box(dummy);

        *ref_to_b.take().unwrap()
    }

    transmute_inner(black_box(&mut DummyEnum::B(None)), obj)
}

pub const QUOTE_SHELLCODE_UNQUOTE: &[u8] = &[
    0x53, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x55, 0x48, 0x89, 0xe5, 0x48, 0x8d, 0x3d,
    0xf4, 0x03, 0x00, 0x00, 0xe8, 0x80, 0x00, 0x00, 0x00, 0x49, 0x89, 0xc4, 0x4d, 0x31, 0xed, 0xe8,
    0x3d, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x3d, 0xe2, 0x03, 0x00, 0x00, 0xe8, 0x69, 0x00, 0x00, 0x00,
    0x48, 0x89, 0xc6, 0x48, 0x8d, 0x3d, 0xd3, 0x03, 0x00, 0x00, 0xe8, 0x79, 0x00, 0x00, 0x00, 0xe8,
    0x42, 0x01, 0x00, 0x00, 0xe8, 0x18, 0x00, 0x00, 0x00, 0x48, 0xb8, 0xef, 0xbe, 0xad, 0xde, 0xce,
    0xfa, 0xed, 0xfe, 0x48, 0x89, 0xec, 0x5d, 0x41, 0x5f, 0x41, 0x5e, 0x41, 0x5d, 0x41, 0x5c, 0x5b,
    0xc3, 0x41, 0x54, 0x41, 0x55, 0x4c, 0x89, 0xe6, 0x48, 0x8d, 0x3d, 0x99, 0x03, 0x00, 0x00, 0xe8,
    0xf1, 0x01, 0x00, 0x00, 0x49, 0x83, 0xc5, 0x01, 0x49, 0x83, 0xfd, 0x1c, 0x7c, 0xe7, 0xe8, 0xfd,
    0x01, 0x00, 0x00, 0x41, 0x5d, 0x41, 0x5c, 0xc3, 0xe8, 0x73, 0xff, 0xff, 0xff, 0xb8, 0x3c, 0x00,
    0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x53, 0x48, 0x31, 0xc0, 0x48, 0x31, 0xdb,
    0x48, 0x8d, 0x0f, 0x8a, 0x19, 0x48, 0x83, 0xc1, 0x01, 0x48, 0x83, 0xc0, 0x01, 0x80, 0xfb, 0x00,
    0x75, 0xf1, 0x48, 0x83, 0xe8, 0x01, 0x5b, 0xc3, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57,
    0x49, 0x89, 0xf8, 0x49, 0x89, 0xf1, 0x48, 0x31, 0xc9, 0x4d, 0x31, 0xd2, 0x4d, 0x31, 0xe4, 0x4d,
    0x31, 0xed, 0x4d, 0x31, 0xff, 0x41, 0xbe, 0x24, 0x00, 0x00, 0x00, 0x41, 0xbd, 0x24, 0x00, 0x00,
    0x00, 0x4c, 0x39, 0xf6, 0x7f, 0x03, 0x49, 0x89, 0xf6, 0x4c, 0x89, 0xee, 0x4c, 0x89, 0xf7, 0xe8,
    0x24, 0x02, 0x00, 0x00, 0x49, 0x89, 0xc2, 0x49, 0x81, 0xe2, 0xff, 0x00, 0x00, 0x00, 0x49, 0x89,
    0xc3, 0x49, 0xc1, 0xeb, 0x08, 0x49, 0x81, 0xe3, 0xff, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc1, 0x48,
    0xc1, 0xe9, 0x10, 0x48, 0x81, 0xe1, 0xff, 0x00, 0x00, 0x00, 0x49, 0x8d, 0x00, 0x4c, 0x01, 0xe0,
    0x48, 0x31, 0xff, 0x40, 0x8a, 0x38, 0x41, 0x88, 0xff, 0x4c, 0x89, 0xd6, 0x4c, 0x89, 0xda, 0x41,
    0x80, 0xff, 0x0a, 0x74, 0x17, 0x41, 0x50, 0x41, 0x51, 0x41, 0x52, 0x41, 0x53, 0xe8, 0x56, 0x00,
    0x00, 0x00, 0x41, 0x5b, 0x41, 0x5a, 0x41, 0x59, 0x41, 0x58, 0xeb, 0x0d, 0x41, 0x55, 0x41, 0x56,
    0xe8, 0xf1, 0x00, 0x00, 0x00, 0x41, 0x5e, 0x41, 0x5d, 0x49, 0x83, 0xc4, 0x01, 0x4d, 0x39, 0xcc,
    0x7d, 0x1b, 0x49, 0x83, 0xc5, 0x01, 0x49, 0x83, 0xff, 0x0a, 0x74, 0x09, 0x4d, 0x39, 0xf5, 0x0f,
    0x8c, 0x74, 0xff, 0xff, 0xff, 0x4d, 0x31, 0xed, 0xe9, 0x6c, 0xff, 0xff, 0xff, 0x41, 0x5f, 0x41,
    0x5e, 0x41, 0x5d, 0x41, 0x5c, 0xc3, 0x48, 0x8d, 0x3d, 0x77, 0x02, 0x00, 0x00, 0xbe, 0x04, 0x00,
    0x00, 0x00, 0xe8, 0xce, 0x00, 0x00, 0x00, 0xc3, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57,
    0x55, 0x48, 0x89, 0xe5, 0x49, 0x89, 0xfc, 0x49, 0x89, 0xf5, 0x49, 0x89, 0xd6, 0x49, 0x89, 0xcf,
    0xbe, 0x07, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x3d, 0x3f, 0x02, 0x00, 0x00, 0xe8, 0xa4, 0x00, 0x00,
    0x00, 0x4c, 0x89, 0xef, 0xe8, 0x58, 0x00, 0x00, 0x00, 0xbe, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8d,
    0x3d, 0x2d, 0x02, 0x00, 0x00, 0xe8, 0x8b, 0x00, 0x00, 0x00, 0x4c, 0x89, 0xf7, 0xe8, 0x3f, 0x00,
    0x00, 0x00, 0xbe, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x3d, 0x14, 0x02, 0x00, 0x00, 0xe8, 0x72,
    0x00, 0x00, 0x00, 0x4c, 0x89, 0xff, 0xe8, 0x26, 0x00, 0x00, 0x00, 0xbe, 0x01, 0x00, 0x00, 0x00,
    0x48, 0x8d, 0x3d, 0xfc, 0x01, 0x00, 0x00, 0xe8, 0x59, 0x00, 0x00, 0x00, 0x4c, 0x89, 0xe7, 0xe8,
    0x32, 0x00, 0x00, 0x00, 0x48, 0x89, 0xec, 0x5d, 0x41, 0x5f, 0x41, 0x5e, 0x41, 0x5d, 0x41, 0x5c,
    0xc3, 0x55, 0x48, 0x89, 0xe5, 0x48, 0x83, 0xec, 0x20, 0x48, 0x8d, 0x75, 0xff, 0xe8, 0xa5, 0x01,
    0x00, 0x00, 0x48, 0x8d, 0x75, 0x00, 0x48, 0x29, 0xc6, 0x48, 0x89, 0xc7, 0xe8, 0x24, 0x00, 0x00,
    0x00, 0x48, 0x89, 0xec, 0x5d, 0xc3, 0x55, 0x48, 0x89, 0xe5, 0x48, 0x83, 0xec, 0x08, 0x40, 0x88,
    0x7d, 0xf8, 0x48, 0x8d, 0x7d, 0xf8, 0xbe, 0x01, 0x00, 0x00, 0x00, 0xe8, 0x05, 0x00, 0x00, 0x00,
    0x48, 0x89, 0xec, 0x5d, 0xc3, 0x55, 0x48, 0x89, 0xe5, 0x48, 0x89, 0xf2, 0x48, 0x89, 0xfe, 0xb8,
    0x01, 0x00, 0x00, 0x00, 0xbf, 0x01, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x89, 0xec, 0x5d, 0xc3,
    0x40, 0xb7, 0x0a, 0xe8, 0xbe, 0xff, 0xff, 0xff, 0xc3, 0x0f, 0x28, 0xd0, 0xf3, 0x0f, 0x5e, 0xd1,
    0xf3, 0x0f, 0x2c, 0xca, 0x66, 0x0f, 0xef, 0xd2, 0xf3, 0x0f, 0x2a, 0xd1, 0xf3, 0x0f, 0x59, 0xca,
    0xf3, 0x0f, 0x5c, 0xc1, 0xc3, 0xf3, 0x0f, 0x58, 0xc1, 0xb8, 0x00, 0x00, 0xc0, 0x40, 0x66, 0x0f,
    0x6e, 0xc8, 0xe8, 0xd2, 0xff, 0xff, 0xff, 0xba, 0x00, 0x00, 0x80, 0x40, 0x66, 0x0f, 0x6e, 0xca,
    0x0f, 0x28, 0xd0, 0xf3, 0x0f, 0x5c, 0xc8, 0xbf, 0x00, 0x00, 0x80, 0x3f, 0x66, 0x0f, 0x6e, 0xc7,
    0x0f, 0x2f, 0xca, 0x76, 0x1b, 0x0f, 0x2f, 0xc2, 0x77, 0x33, 0xf3, 0x0f, 0x5d, 0xd0, 0xf3, 0x0f,
    0x5c, 0xc2, 0xbe, 0x00, 0x00, 0x7f, 0x43, 0x66, 0x0f, 0x6e, 0xde, 0xf3, 0x0f, 0x59, 0xc3, 0xc3,
    0x0f, 0x2f, 0xc1, 0x77, 0x05, 0x0f, 0x28, 0xd1, 0xeb, 0xe0, 0x66, 0x0f, 0xef, 0xd2, 0x0f, 0x2f,
    0xca, 0x77, 0xf2, 0xb8, 0x00, 0x00, 0x7f, 0x43, 0x66, 0x0f, 0x6e, 0xc0, 0xc3, 0x66, 0x0f, 0xef,
    0xc9, 0x0f, 0x2f, 0xd1, 0x77, 0xc4, 0xeb, 0xeb, 0x55, 0x48, 0x89, 0xe5, 0x48, 0x83, 0xec, 0x18,
    0x89, 0x7d, 0xe4, 0x89, 0x75, 0xe0, 0xb8, 0x00, 0x00, 0xb4, 0x43, 0xbf, 0x00, 0x00, 0x70, 0x42,
    0xbe, 0x00, 0x00, 0xa0, 0x40, 0x66, 0x0f, 0xef, 0xc0, 0xf3, 0x0f, 0x2a, 0x45, 0xe0, 0x66, 0x0f,
    0xef, 0xd2, 0xf3, 0x0f, 0x2a, 0x55, 0xe4, 0x0f, 0x28, 0xc8, 0xf3, 0x0f, 0x5e, 0xca, 0x66, 0x0f,
    0x6e, 0xc0, 0xf3, 0x0f, 0x59, 0xc1, 0xf3, 0x0f, 0x11, 0x45, 0xec, 0x66, 0x0f, 0x6e, 0xcf, 0xf3,
    0x0f, 0x5e, 0xc1, 0xf3, 0x0f, 0x11, 0x45, 0xf0, 0xc6, 0x45, 0xf4, 0x00, 0xf3, 0x0f, 0x10, 0x45,
    0xf0, 0x0f, 0x28, 0xc8, 0x66, 0x0f, 0x6e, 0xc6, 0xe8, 0x28, 0xff, 0xff, 0xff, 0xb9, 0x00, 0x00,
    0x40, 0x40, 0xf3, 0x0f, 0x2c, 0xc0, 0x0f, 0xb6, 0xc0, 0x09, 0x45, 0xf4, 0xf3, 0x0f, 0x10, 0x45,
    0xf0, 0x0f, 0x28, 0xc8, 0x66, 0x0f, 0x6e, 0xc1, 0xe8, 0x08, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x2c,
    0xf8, 0x40, 0x0f, 0xb6, 0xd7, 0xb8, 0x00, 0x00, 0x80, 0x3f, 0xc1, 0xe2, 0x08, 0x09, 0x55, 0xf4,
    0xf3, 0x0f, 0x10, 0x45, 0xf0, 0x0f, 0x28, 0xc8, 0x66, 0x0f, 0x6e, 0xc0, 0xe8, 0xe4, 0xfe, 0xff,
    0xff, 0xf3, 0x0f, 0x2c, 0xf0, 0x40, 0x0f, 0xb6, 0xce, 0xc1, 0xe1, 0x10, 0x09, 0x4d, 0xf4, 0x8b,
    0x45, 0xf4, 0x48, 0x89, 0xec, 0x5d, 0xc3, 0x41, 0xb8, 0x0a, 0x00, 0x00, 0x00, 0x89, 0xf8, 0x31,
    0xd2, 0x49, 0xf7, 0xf0, 0x89, 0xc1, 0x83, 0xc2, 0x30, 0x88, 0x16, 0x48, 0x83, 0xee, 0x01, 0x85,
    0xc0, 0x75, 0xec, 0x48, 0x89, 0xf0, 0x48, 0x83, 0xc0, 0x01, 0xc3, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
    0x32, 0x3b, 0x3b, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0xf0, 0x9f, 0xa6, 0x80, 0x00, 0x52, 0x75, 0x73,
    0x74, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x6d, 0x61, 0x6e, 0x79, 0x2d, 0x73, 0x70, 0x6c, 0x65,
    0x6e, 0x64, 0x6f, 0x72, 0x65, 0x64, 0x20, 0x74, 0x68, 0x69, 0x6e, 0x67, 0x0a, 0x49, 0x74, 0x27,
    0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x41, 0x70, 0x72, 0x69, 0x6c, 0x20, 0x72, 0x6f, 0x73, 0x65,
    0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x67, 0x72, 0x6f, 0x77, 0x73,
    0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x61, 0x72, 0x6c, 0x79, 0x20, 0x73, 0x70,
    0x72, 0x69, 0x6e, 0x67, 0x0a, 0x52, 0x75, 0x73, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x61, 0x74,
    0x75, 0x72, 0x65, 0x27, 0x73, 0x20, 0x77, 0x61, 0x79, 0x20, 0x6f, 0x66, 0x20, 0x67, 0x69, 0x76,
    0x69, 0x6e, 0x67, 0x0a, 0x41, 0x20, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x20, 0x74, 0x6f, 0x20,
    0x62, 0x65, 0x20, 0x6c, 0x69, 0x76, 0x69, 0x6e, 0x67, 0x0a, 0x54, 0x68, 0x65, 0x20, 0x62, 0x6f,
    0x72, 0x72, 0x6f, 0x77, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x65, 0x72, 0x20, 0x6d, 0x61, 0x6b,
    0x65, 0x73, 0x20, 0x61, 0x20, 0x6d, 0x61, 0x6e, 0x20, 0x61, 0x20, 0x6b, 0x69, 0x6e, 0x67, 0x0a,
    0x00, 0x90,
];
